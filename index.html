<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <style>
        .gridlines line {
            stroke: #bbb;
        }

        .gridlines .domain {
            stroke: none;
        }

        h2 {
            font-size: 48px;
        }

        .outline {
            stroke: black;
            stroke-width: 1px;
            fill: none;
        }

        .heading {
            text-align: center;
            padding: 10px;
            margin-top: 30px;
        }

        .select {
            text-align: right;
            margin-right: 20em;
        }

        .state_graph {
            margin-top: 80px;
        }

        .mouseover {
            stroke-width: 3px;
            pointer-events: none;
        }

        #us_map_div, #state_map_div {
            text-align: center;
        }

        #colorLegend {
            font-size: 20px;
        }
        html {
            height: 10000px;
        }

    </style>
    <title>Project 2</title>
</head>
<body>
    <div>
        <h2 class = "heading">Real Estate Trends</h2>
        <div class="select">
            <select id="year-select" style="width: 260px;">
            </select>
        </div>
    </div>
    <div id = "us_map_div">
        <svg id="us_map" height="1000" width="1200"></svg>
        <svg id="colorLegend" height="100" width="760" style="background: #fff; margin-top:30px" ></svg>
    </div>

    <div class="state_graph">
        <h2 class = "heading">State Real Estate Trend</h2>
        <div class="select">
            <select id="state-select" style="width: 260px;">
            </select>
        </div>
        <div id = "state_map_div">
            <svg id="state_map" height="1000" width="1200"></svg>
        </div>
    </div>
    
    <script>
        const svg = d3.select("#us_map");
        const width = svg.attr("width");
        const height = svg.attr("height");
        const margin = { top: 10, right: 10, bottom: 10, left:10};
        const mapWidth = width - margin.left - margin.right;
        const mapHeight = height - margin.top - margin.bottom;
        // const map = svg.append("g");
        const map = svg.append("g")
                  .attr("transform","translate("+margin.left+","+margin.top+")");
                        
        const state_svg = d3.select("#state_map");
        const state_width = state_svg.attr("width");
        const state_height = state_svg.attr("height");
        const state_margin = {top: 10, right: 10, bottom: 50, left: 50};
        const chartWidth = width - state_margin.left - state_margin.right;
        const chartHeight = height - state_margin.top - state_margin.bottom;
        let annotations = state_svg.append("g").attr("id","annotations");
        let chartArea = state_svg.append("g")
                .attr("id","points")
                .attr("transform",`translate(${state_margin.left},${state_margin.top})`);

        const requestData = async function() {
            const us = await d3.json("../data/us-smaller.json");
            let selected_year = "2016";
            let selected_state = "AL";
            var states = topojson.feature(us, us.objects.states);
            var statesMesh = topojson.mesh(us, us.objects.states);
            var projection = d3.geoAlbersUsa().fitSize([width, height], states);
            var path = d3.geoPath().projection(projection);

            map.selectAll("path.state").data(states.features)
                .join("path")
                .attr("class", "state")
                .attr("note", d => d.id)
                .attr("d", path);
            
            map.append("path").datum(statesMesh)
                .attr("class","outline")
                .attr("stroke-width", 1)
                .attr("stroke", "white")
                .attr("d", path);
            
            const listings = await d3.json("../data/listings.json");
            var stateIDs = await d3.tsv("../data/us-state-names.tsv");
            let idToState = {}
  
            stateIDs.forEach( row => {
                idToState[row.id] = row.code;
            });

            let listing_data = {}
            listings.forEach( row => {
                year = row["month_date_yyyymm"].toString().slice(0,4);
                if (year in listing_data) {
                    if (Object.keys(listing_data[year]).includes(row["state_id"])) {
                        listing_data[year][row["state_id"].toUpperCase()][0] += row["median_listing_price_per_square_foot"];
                        listing_data[year][row["state_id"].toUpperCase()][1] += (row["price_increased_count"]/row["total_listing_count"])*100;
                        listing_data[year][row["state_id"].toUpperCase()][2] += (row["price_reduced_count"]/row["total_listing_count"])*100;
                        listing_data[year][row["state_id"].toUpperCase()][3] += 1;
                    }  else {
                        listing_data[year][row["state_id"].toUpperCase()] = [row["median_listing_price_per_square_foot"], 
                                                            (row["price_increased_count"]/row["total_listing_count"])*100,
                                                            (row["price_reduced_count"]/row["total_listing_count"])*100, 1]
                    }
                } else {
                    var state = new Object();
                    state[row["state_id"].toUpperCase()] = [row["median_listing_price_per_square_foot"], 
                                                            (row["price_increased_count"]/row["total_listing_count"])*100,
                                                            (row["price_reduced_count"]/row["total_listing_count"])*100, 1]
                    listing_data[year] = state;
                }
            })

            let min = Infinity;
            let max = -Infinity;

            Object.values(listing_data).forEach(year => {
                for (const [key, value] of Object.entries(year)) {
                    value[0]/=value[3];
                    value[1]/=value[3];
                    value[2]/=value[3];
                    if (value[0] < min) {
                        min = value[0]
                    } else if (value[0] > max) {
                        max = value[0]
                    }
                }
            })

            console.log("min", min)
            console.log("max", max)

            let state_filter = d3.select("#state-select");
            Object.values(idToState).forEach(d => {
                let element = document.getElementById("state-select")
                let select = document.createElement("option");
                select.value = d;
                let node = document.createTextNode(d);
                select.appendChild(node);
                element.appendChild(select);
            })

            function state_added() {
                selected_state = this.value;
                d3.select("path.line").remove();
                let states_data = [];
                let state_abbrev = idToState[this.getAttribute("note")];
                let state_medians = [];
                Object.keys(listing_data).forEach(d=>{
                    state_medians.push(listing_data[d][state_abbrev][0])  ;
                })
                states_data.push({
                    key:   state_abbrev,
                    value: state_medians
                });

                console.log("click");

                states_data.forEach(state_data => {
                    console.log(state_data);
                    chartArea.selectAll("circle").data(Object.values(state_data))
                        .join("circle")
                        .attr("r", 8)
                        .attr("fill", "#dd403a")
                        .attr("cx", (d, i) => console.log(d,i))
                        // dateScale(Object.keys(listing_data)[i]) )
                        .attr("cy", d => stateScale(d) );
                })
            }

                // chartArea.selectAll("circle").data(state_data)
                //     .join("circle")
                //     .attr("r", 8)
                //     .attr("fill", "#dd403a")
                //     .attr("cx", (d, i) => dateScale(Object.keys(listing_data)[i]) )
                //     .attr("cy", d => stateScale(d) );
                
                // lineGen = d3.line()
                //   .x( (d, i) => dateScale(Object.keys(listing_data)[i]) )
                //   .y( d => stateScale(d) )
                //   .curve(d3.curveMonotoneX);
                
                // chartArea.append("path")
                //     .datum(state_data)
                //     .attr("class", "line")
                //     .attr("fill", "none")
                //     .attr("stroke", "#dd403a")
                //     .attr("stroke-width", 3)
                //     .attr("opacity", 0.6)
                //     .attr("d", lineGen);

            let state_data = []
            d3.selectAll(".state").on("click", state_added);

            let stateScale = d3.scaleLinear().domain([0, max]).range([chartHeight, 0]);
            const dateExtent = d3.extent(Object.keys(listing_data));
            const dateScale = d3.scaleLinear().domain(dateExtent).range([0,chartWidth]);
            console.log(state_data)
            let leftAxis = d3.axisLeft(stateScale)
            let leftGridlines = d3.axisLeft(stateScale)
                                    .tickSize(-chartWidth-10)
                                    .tickFormat(d3.format("$d"))
            // annotations.append("g")
            //     .attr("class", "y axis")
            //     .attr("transform",`translate(${margin.left-10},${margin.top})`)
            //     .call(leftAxis)
            annotations.append("g")
                .attr("class", "y gridlines")
                .attr("transform",`translate(${state_margin.left-10},${state_margin.top})`)
                .call(leftGridlines);

            let bottomAxis = d3.axisBottom(dateScale)
            let bottomGridlines = d3.axisBottom(dateScale)
                                    .ticks(6)
                                    .tickSize(-chartHeight-10)
                                    .tickFormat(d3.format("d"));

            // annotations.append("g")
            //     .attr("class", "x axis")
            //     .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
            //     .call(bottomAxis);
            annotations.append("g")
                .attr("class", "x gridlines")
                .attr("transform",`translate(${state_margin.left},${chartHeight+state_margin.top+10})`)
                .call(bottomGridlines);
            

            var lineGen = d3.line()
                  .x( (d, i) => dateScale(Object.keys(listing_data)[i]) )
                  .y( d => stateScale(d) )
                  .curve(d3.curveMonotoneX);
                
            chartArea.append("path")
                .datum(state_data)
                .attr("class", "line")
                .attr("fill", "none")
                .attr("stroke", "#dd403a")
                .attr("stroke-width", 3)
                .attr("opacity", 0.6)
                .attr("d", lineGen);

            chartArea.selectAll("circle").data(state_data)
                .join("circle")
                .attr("r", 8)
                .attr("fill", "#dd403a")
                .attr("cx", (d, i) => dateScale(Object.keys(listing_data)[i]) )
                .attr("cy", d => stateScale(d) );

            

            let year_filter = d3.select("#year-select");
            Object.keys(listing_data).forEach( d => {
                let element = document.getElementById("year-select")
                let select = document.createElement("option");
                select.value = d;
                let node = document.createTextNode(d);
                select.appendChild(node);
                element.appendChild(select);
            })

            year_filter.on("change", function() {
                var legendSvg = d3.select("#colorLegend");
                legendSvg.selectAll("*").remove();
                selected_year = this.value;

                var dataFilter = listing_data[selected_year];

                minMax = d3.extent(Object.values(listing_data[selected_year]), d => d[0]);
                colorScale = d3.scaleQuantile()
                         .domain(minMax)
                         .range([ "#f7b267","#ff8a5b","#f25c54","#dd403a"]);

                map.selectAll(".state")
                    // .datum(dataFilter)
                    // .transition()
                    // .duration(1000)
                    // .style("fill", d => Object.values(d)[0][0])
                    
                    .style("fill", d => {
                        if (typeof(listing_data[selected_year][idToState[d.id]]) == "undefined") {
                            listing_data[selected_year][idToState[d.id]] = [];
                        }
                        return colorScale( listing_data[selected_year][ idToState[d.id] ][0] );
                });
                drawLegend(d3.select("#colorLegend"), colorScale);
            })

    //         var dataFilter = data.filter(function(d){return d.name==selectedGroup})

    //   // Give these new data to update line
    //   line
    //       .datum(dataFilter)
    //       .transition()
    //       .duration(1000)
    //       .attr("d", d3.line()
    //         .x(function(d) { return x(d.year) })
    //         .y(function(d) { return y(+d.n) })
    //       )
    //       .attr("stroke", function(d){ return myColor(selectedGroup) })

            let minMax = d3.extent(Object.values(listing_data[selected_year]), d => d[0]);

            // How to choose colors ?
            let colorScale = d3.scaleQuantile()
                         .domain(minMax)
                         .range(["#f7b267","#ff8a5b","#f25c54","#dd403a"]);

            map.selectAll(".state")
                .style("fill", d => {
                    if (typeof(listing_data[selected_year][idToState[d.id]]) == "undefined") {
                        listing_data[selected_year][idToState[d.id]] = [];
                    }
                    return colorScale( listing_data[selected_year][ idToState[d.id] ][0] );
                });

            drawLegend(d3.select("#colorLegend"), colorScale)

            let tooltipWidth = 140;
            let tooltipHeight = 80;
            let tooltip = map.append("g")
                    .attr("class","tool")
                    .attr("visibility","visible");

            tooltip.append("rect")
                .attr("fill", "white")
                .attr("opacity", 0.9)
                .attr("x", -tooltipWidth / 2.0)
                .attr("y", 0)
                .attr("width",tooltipWidth)
                .attr("height",tooltipHeight)
                .attr("rx", 6)
                .attr("ry", 6)

            let txt = tooltip.append("text")
                            .attr("text-anchor","middle")
                            .attr("alignment-baseline","hanging")
                            .attr("x", 0)
                            .attr("y", 2);

            let txt2 = tooltip.append("text")
                            .attr("fill", "black")
                            .attr("text-anchor","middle")
                            .attr("alignment-baseline","hanging")
                            .attr("x", 0)
                            .attr("y", 22);
                
            let txt3 = tooltip.append("text")
                            .attr("fill", "black")
                            .attr("text-anchor","middle")
                            .attr("alignment-baseline","hanging")
                            .attr("x", 0)
                            .attr("y", 42);
            
            let txt4 = tooltip.append("text")
                            .attr("fill", "black")
                            .attr("text-anchor","middle")
                            .attr("alignment-baseline","hanging")
                            .attr("x", 0)
                            .attr("y", 62);
            
            let mesh =  map.append("path")
                    .attr("class","mouseover outline")
                    .attr("d", "");
                     
            d3.selectAll(".state").on("mouseenter", mouseEntersPlot);
            d3.selectAll(".state").on("mouseout",  mouseLeavesPlot);
        
            function mouseEntersPlot() {
                tooltip.style("visibility", "visible")
                let state = d3.select(this);
                let stateID = state.datum().id;

                var mo = topojson.mesh(us, us.objects.states, function(a, b) { return a.id === stateID || b.id === stateID; });
                mesh.datum(mo).attr("d", path);
        
                txt.text(idToState[ stateID ]);
                txt2.text("$"+listing_data[selected_year][idToState[ stateID ]][0].toFixed(2)+"/sq ft");
                txt3.text(listing_data[selected_year][idToState[ stateID ]][1].toFixed(2)+"% increase");
                txt4.text(listing_data[selected_year][idToState[ stateID ]][2].toFixed(2)+"% decrease");

                let bounds = path.bounds( state.datum() ); 
                let xPos = (bounds[0][0]+bounds[1][0])/2.0;
                let yPos = bounds[1][1];
            
                tooltip.attr("transform",`translate(${xPos},${yPos})`);
            }
        
            function mouseLeavesPlot() {
                // console.log("out");
                tooltip.style("visibility","hidden");
        
                let state = d3.select(this);
                // state.attr("stroke","none").attr("stroke-width", 0);
                mesh.attr("d", "");
            }

            function drawLegend(legend, legendColorScale) {
      
                // Bonus code here to draw an adaptive gradient legend so we can see different color scales for choropleth maps
                //  Credit Prof. Rz if you are basing a legend on this structure, and note SERIOUS PERFORMANCE CONSIDERATIONS
                
                //const legend = d3.select("#colorLegend");
                const legendWidth = legend.attr("width");
                const legendHeight = legend.attr("height");
                const legendMinMax = d3.extent(legendColorScale.domain()); // way to recover the minMax from most kinds of scales
                const barHeight = 60;
                const stepSize = 4; // warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance
                // Extend the minmax by 1 in either direction to expose more features
                const pixelScale = d3.scaleLinear().domain([0,legendWidth-40]).range([legendMinMax[0]-1,legendMinMax[1]+1]); // In this case the "data" are pixels, and we get numbers to use in colorScale
                const barScale = d3.scaleLinear().domain([legendMinMax[0]-1,legendMinMax[1]+1]).range([0,legendWidth-40]);
                const barAxis = d3.axisBottom(barScale);
                // Check if we're using a quantile scale - if so, we can do better
                if (legendColorScale.hasOwnProperty('quantiles')) {
                    // Use the quantile breakpoints plus the min and max of the scale as tick values
                    barAxis.tickValues(legendColorScale.quantiles().concat( legendMinMax )).tickFormat(function(d,i) {
                        return "$" + Math.round(d) + "/sq ft";
                    });
                }
                legend.append("g")
                    .attr("class", "colorbar axis")
                    .attr("transform","translate("+(20)+","+(barHeight+5)+")")
                    .call(barAxis);
                // Draw rects of color down the bar
                let bar = legend.append("g").attr("transform","translate("+(20)+","+(0)+")")
                for (let i=0; i<legendWidth-40; i=i+stepSize) {
                    bar.append("rect")
                    .attr("x", i)
                    .attr("y", 0)
                    .attr("width", stepSize)
                    .attr("height",barHeight)
                    .style("fill", legendColorScale( pixelScale(i) )); // pixels => countData => color
                }
                // Put lines in to mark actual min and max of our data
                bar.append("line").attr("stroke","white").attr("stroke-width",3).attr("x1", barScale(legendMinMax[0])).attr("x2", barScale(legendMinMax[0])).attr("y1", 0).attr("y1", barHeight+4);
                bar.append("line").attr("stroke","white").attr("stroke-width",3).attr("x1", barScale(legendMinMax[1])).attr("x2", barScale(legendMinMax[1])).attr("y1", 0).attr("y1", barHeight+4);
                
                }
        }
        requestData();
    </script>
</body>
</html>